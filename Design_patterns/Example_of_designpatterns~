COMPOSITE PATTERN

Composite lets clients treat individual objects and compositions of objects uniformly.


interface Component { void traverse(); }      // 1. "lowest common denominator" 

	class Primitive implements Component {        // 2. "Isa" relationship
	   private int value;
	   public Primitive( int val ) { value = val; }
	   public void traverse()      { System.out.print( value + "  " ); }
	}

	abstract class Composite1 implements Component {      // 2. "Isa" relationship
	   private Component[] children = new Component[9];  // 3. Couple to interface
	   private int         total    = 0;
	   private int         value;
	   
	public Composite1( int val )    { value = val; }
	   public void add( Component c ) { children[total++] = c; } // 3. Couple to
	   public void traverse() {                                  //    interface
	      System.out.print( value + "  " );
	      for (int i=0; i < total; i++)
	          children[i].traverse();            // 4. Delegation and polymorphism 
	}  }

	class Row extends Composite1 {                // Two different kinds of "con-
	   public Row( int val ) { super( val ); }   // tainer" classes.  Most of the
	   public void traverse() {                  // "meat" is in the Composite
	      System.out.print( "Row" );             // base class.
	      super.traverse();
	}  }

	class Column extends Composite1 {
	   public Column( int val ) { super( val ); }
	   public void traverse() {
	      System.out.print( "Col" );
	      super.traverse();
	}  


	   public static void main( String[] args ) {
	      Composite1 first  = new Row( 1 );          // Row1
	      Composite1 second = new Column( 2 );       //   |
	      Composite1 third  = new Column( 3 );       //   +-- Col2
	      Composite1 fourth = new Row( 4 );          //   |     |
	      Composite1 fifth  = new Row( 5 );          //   |     +-- 7
	      first.add( second );                      //   +-- Col3
	      first.add( third  );                      //   |     |
	      third.add( fourth );                      //   |     +-- Row4
	      third.add( fifth  );                      //   |     |     |
	      first.add(  new Primitive( 6 ) );         //   |     |     +-- 9
	      second.add( new Primitive( 7 ) );         //   |     +-- Row5
	      third.add(  new Primitive( 8 ) );         //   |     |     |
	      fourth.add( new Primitive( 9 ) );         //   |     |     +-- 10
	      fifth.add(  new Primitive(10 ) );         //   |     +-- 8
	      first.traverse();                         //   +-- 6
	}  }



PROXY PATTERN



//Image interface
public interface Image{  
	
	
	public void displayImage();
	
}

//RealImage that implements Image interface


public class RealImage implements Image{  
	public RealImage()   {    
		//load up the image      
		loadImage();   }  
	
	
	public void displayImage()   {       
		//display the image  
		} 
		
		//a method that only the real image has   
	
	private void loadImage()  {      //do resource intensive operation to load image  }}
	}
}


//ProxyImage the proxy class for RealImage

public class ProxyImage implements Image{    
	
	//private URL url;   
	public ProxyImage()    
	{       //this.url = url; 
		
	}    //this method delegates to the real image    
	
	
	public void displayImage()   {        
		
		RealImage real = new RealImage();        
		real.displayImage();   
		
	}}



COMMAND PATTERN

public interface Order {
   void execute();
}

public class Stock {
	
   private String name = "ABC";
   private int quantity = 10;

   public void buy(){
      System.out.println("Stock [ Name: "+name+", 
         Quantity: " + quantity +" ] bought");
   }
   public void sell(){
      System.out.println("Stock [ Name: "+name+", 
         Quantity: " + quantity +" ] sold");
   }
}

public class BuyStock implements Order {
   private Stock abcStock;

   public BuyStock(Stock abcStock){
      this.abcStock = abcStock;
   }

   public void execute() {
      abcStock.buy();
   }
}

public class SellStock implements Order {
   private Stock abcStock;

   public SellStock(Stock abcStock){
      this.abcStock = abcStock;
   }

   public void execute() {
      abcStock.sell();
   }
}


import java.util.ArrayList;
import java.util.List;

   public class Broker {
   private List<Order> orderList = new ArrayList<Order>(); 

   public void takeOrder(Order order){
      orderList.add(order);		
   }

   public void placeOrders(){
   
      for (Order order : orderList) {
         order.execute();
      }
      orderList.clear();
   }
}
public class CommandPatternDemo {
   public static void main(String[] args) {
      Stock abcStock = new Stock();

      BuyStock buyStockOrder = new BuyStock(abcStock);
      SellStock sellStockOrder = new SellStock(abcStock);

      Broker broker = new Broker();
      broker.takeOrder(buyStockOrder);
      broker.takeOrder(sellStockOrder);

      broker.placeOrders();
   }
}


ITERATOR PATTERN


public class Item {

	String name;
	float price;

	public Item(String name, float price) {
		this.name = name;
		this.price = price;
	}

	public String toString() {
		return name + ": $" + price;
	}
}

//Menu.java
//Iterator function logic
package com.cakes;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class Menu {

	List<Item> menuItems;

	public Menu() {
		menuItems = new ArrayList<Item>();
	}

	public void addItem(Item item) {
		menuItems.add(item);
	}

	public Iterator<Item> iterator() {
		return new MenuIterator();
	}

	class MenuIterator implements Iterator<Item> {
		int currentIndex = 0;

		@Override
		public boolean hasNext() {
			if (currentIndex >= menuItems.size()) {
				return false;
			} else {
				return true;
			}
		}

		@Override
		public Item next() {
			return menuItems.get(currentIndex++);
		}

		@Override
		public void remove() {
			menuItems.remove(--currentIndex);
		}

	}

}

//Demo.java
// Iterator function use

package com.cakes;

import java.util.Iterator;

public class Demo {

	public static void main(String[] args) {

		Item i1 = new Item("spaghetti", 7.50f);
		Item i2 = new Item("hamburger", 6.00f);
		Item i3 = new Item("chicken sandwich", 6.50f);

		Menu menu = new Menu();
		menu.addItem(i1);
		menu.addItem(i2);
		menu.addItem(i3);

		System.out.println("Displaying Menu:");
		Iterator<Item> iterator = menu.iterator();
		while (iterator.hasNext()) {
			Item item = iterator.next();
			System.out.println(item);
		}

		System.out.println("\nRemoving last item returned");
		iterator.remove();

		System.out.println("\nDisplaying Menu:");
		iterator = menu.iterator();
		while (iterator.hasNext()) {
			Item item = iterator.next();
			System.out.println(item);
		}

	}

}



ADAPTER PATTERN


class SquarePeg {
   private double width;
   public SquarePeg( double w )       { width = w; }
   public double getWidth()           { return width; }
   public void   setWidth( double w ) { width = w; }
}

/* The NEW */
class RoundHole {
   private int radius;
   public RoundHole( int r ) {
      radius = r;
      System.out.println( "RoundHole: max SquarePeg is " + r * Math.sqrt(2) );
   }
   public int getRadius() { return radius; }
}

// Design a "wrapper" class that can "impedance match" the old to the new
class SquarePegAdapter {

   // The adapter/wrapper class "has a" instance of the legacy class
   private SquarePeg sp;

   public SquarePegAdapter( double w ) { sp = new SquarePeg( w ); }

   // Identify the desired interface
   public void makeFit( RoundHole rh ) {
      // The adapter/wrapper class delegates to the legacy object
      double amount = sp.getWidth() - rh.getRadius() * Math.sqrt(2);
      System.out.println( "reducing SquarePeg " + sp.getWidth() + " by " + ((amount < 0) ? 0 : amount) + " amount" );
      if (amount > 0) {
         sp.setWidth( sp.getWidth() - amount );
         System.out.println( "   width is now " + sp.getWidth() );
      }
   }
}

class AdapterDemoSquarePeg {
   public static void main( String[] args ) {
      RoundHole        rh = new RoundHole( 5 );
      SquarePegAdapter spa;

      for (int i=6; i < 10; i++) {
         spa = new SquarePegAdapter( (double) i );
         // The client uses (is coupled to) the new interface
         spa.makeFit( rh );
      }
   }
}



FACADE

//shape interface

Shape.java

public interface Shape {
   void draw();
}

//Class using the shape interface
Rectangle.java

public class Rectangle implements Shape {

   @Override
   public void draw() {
      System.out.println("Rectangle::draw()");
   }
}

//Class using the shape interface

Square.java

public class Square implements Shape {

   @Override
   public void draw() {
      System.out.println("Square::draw()");
   }
}

//Class using the shape interface


Circle.java

public class Circle implements Shape {

   @Override
   public void draw() {
      System.out.println("Circle::draw()");
   }
}
//creting facade classes containing methods for all shapes

ShapeMaker.java

public class ShapeMaker {
   private Shape circle;
   private Shape rectangle;
   private Shape square;

   public ShapeMaker() {
      circle = new Circle();
      rectangle = new Rectangle();
      square = new Square();
   }

   public void drawCircle(){
      circle.draw();
   }
   public void drawRectangle(){
      rectangle.draw();
   }
   public void drawSquare(){
      square.draw();
   }
}

//using facade class

public class FacadePatternDemo {
   public static void main(String[] args) {
      ShapeMaker shapeMaker = new ShapeMaker();

      shapeMaker.drawCircle();
      shapeMaker.drawRectangle();
      shapeMaker.drawSquare();		
   }
}



DECORATOR PATTERN

interface Widget {
  void draw();
}

// 3. "Core" class with "is a" relationship
class TextField implements Widget {
  private int width, height;
  public TextField( int w, int h ) {
    width  = w;
    height = h;
  }
  public void draw() {
    System.out.println( "TextField: " + width + ", " + height );
  }
}

// 2. Second level base class with "isa" relationship
abstract class Decorator implements Widget {
  private Widget wid; // 4. "has a" relationship

  public Decorator( Widget w ) {
    wid = w;
  }

  // 5. Delegation
  public void draw() {
    wid.draw();
  }
}

// 6. Optional embellishment
class BorderDecorator extends Decorator {
  public BorderDecorator( Widget w ) {
    super( w );
  }
  public void draw() {
    super.draw(); // 7. Delegate to base class and add extra stuff
    System.out.println("  BorderDecorator");
  }
}

// 6. Optional embellishment
class ScrollDecorator extends Decorator {
  public ScrollDecorator( Widget w ) {
    super( w );
  }
  public void draw() {
    super.draw(); // 7. Delegate to base class and add extra stuff
    System.out.println( "  ScrollDecorator" );
  }
}

public class DecoratorDemo {
  public static void main( String[] args ) {
    // 8. Client has the responsibility to compose desired configurations
    Widget aWidget = new BorderDecorator(
                       new BorderDecorator(
                         new ScrollDecorator(
                           new TextField( 80, 24 ))));
    aWidget.draw();
  }
}




